/// Flutter Telemetry Service
///
/// This file demonstrates how to integrate telemetry into a Flutter app
/// using the FFI bridge to the Rust core.
///
/// Usage:
/// ```dart
/// // Initialize
/// final telemetry = TelemetryService();
/// await telemetry.initialize();
///
/// // Track events
/// await telemetry.trackSessionStart();
/// await telemetry.trackScenarioComplete('morning-warmup-01', 180, 85.0);
///
/// // Background sync
/// await telemetry.syncIfNeeded();
/// ```

import 'dart:async';
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:crypto/crypto.dart';
import 'package:uuid/uuid.dart';

// Import your FFI bridge (generated by flutter_rust_bridge)
// import 'package:liminal_app/bridge/bridge.generated.dart';

class TelemetryService {
  static const String _version = '1.0.0';

  String? _sessionId;
  String? _userId;
  DeviceContext? _context;

  Timer? _syncTimer;
  bool _isInitialized = false;

  /// Configuration
  final TelemetryConfig config = TelemetryConfig(
    enabled: true,
    batchSize: 50,
    batchMaxAgeSeconds: 3600, // 1 hour
    batchMaxSizeBytes: 100000, // 100KB
    wifiOnly: true,
  );

  /// Initialize telemetry service
  Future<void> initialize() async {
    if (_isInitialized) return;

    // Generate session ID
    _sessionId = const Uuid().v4();

    // Get or create anonymized user ID
    _userId = await _getOrCreateUserId();

    // Collect device context
    _context = await _collectDeviceContext();

    // Start background sync timer (every hour)
    _syncTimer = Timer.periodic(
      const Duration(hours: 1),
      (_) => syncIfNeeded(),
    );

    _isInitialized = true;
    print('‚úÖ Telemetry initialized - Session: $_sessionId');
  }

  /// Dispose and cleanup
  void dispose() {
    _syncTimer?.cancel();
    _isInitialized = false;
  }

  /// Track session start
  Future<void> trackSessionStart() async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'session_start',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'entry_point': 'app_icon',
          'timestamp': DateTime.now().toIso8601String(),
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: session_start');
    } catch (e) {
      print('‚ùå Failed to track session_start: $e');
    }
  }

  /// Track session end
  Future<void> trackSessionEnd(int durationSeconds) async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'session_end',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'duration_seconds': durationSeconds,
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: session_end');
    } catch (e) {
      print('‚ùå Failed to track session_end: $e');
    }
  }

  /// Track scenario start
  Future<void> trackScenarioStart(String scenarioId) async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'scenario_start',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'scenario_id': scenarioId,
          'started_at': DateTime.now().toIso8601String(),
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: scenario_start - $scenarioId');
    } catch (e) {
      print('‚ùå Failed to track scenario_start: $e');
    }
  }

  /// Track scenario complete
  Future<void> trackScenarioComplete(
    String scenarioId,
    int durationSeconds,
    double score,
  ) async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'scenario_complete',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'scenario_id': scenarioId,
          'duration_seconds': durationSeconds,
          'score': score,
          'completion_rate': 1.0,
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: scenario_complete - $scenarioId');
    } catch (e) {
      print('‚ùå Failed to track scenario_complete: $e');
    }
  }

  /// Track phrase marked as used in wild
  Future<void> trackPhraseWild(String phrase) async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'phrase_marked_wild',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'phrase': phrase,
          'source': 'lesson',
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: phrase_marked_wild - $phrase');
    } catch (e) {
      print('‚ùå Failed to track phrase_marked_wild: $e');
    }
  }

  /// Track screen view
  Future<void> trackScreenView(String screenName) async {
    if (!_isInitialized || !config.enabled) return;

    try {
      await trackEvent(
        'screen_view',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'screen_name': screenName,
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: screen_view - $screenName');
    } catch (e) {
      print('‚ùå Failed to track screen_view: $e');
    }
  }

  /// Track error
  Future<void> trackError(String errorType, String errorMessage) async {
    if (!_isInitialized) return; // Always track errors even if disabled

    try {
      await trackEvent(
        'error',
        sessionId: _sessionId,
        userId: _userId,
        propertiesJson: jsonEncode({
          'error_type': errorType,
          'error_message': errorMessage,
          'severity': 'error',
        }),
        contextJson: jsonEncode(_context!.toJson()),
      );
      print('üìä Tracked: error - $errorType');
    } catch (e) {
      print('‚ùå Failed to track error: $e');
    }
  }

  /// Get telemetry statistics
  Future<TelemetryStats?> getStats() async {
    try {
      final statsJson = await getTelemetryStats();
      final stats = jsonDecode(statsJson);
      return TelemetryStats.fromJson(stats);
    } catch (e) {
      print('‚ùå Failed to get stats: $e');
      return null;
    }
  }

  /// Sync telemetry if conditions are met
  Future<void> syncIfNeeded() async {
    if (!_isInitialized || !config.enabled) return;

    try {
      // Check WiFi requirement
      if (config.wifiOnly) {
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.wifi) {
          print('‚è∏Ô∏è  Skipping sync - WiFi only mode enabled');
          return;
        }
      }

      // Get pending events
      final eventsJson = await getPendingTelemetryEvents(config.batchSize);
      final events = jsonDecode(eventsJson) as List;

      if (events.isEmpty) {
        print('‚úÖ No events to sync');
        return;
      }

      print('üì¶ Syncing ${events.length} events...');

      // Create batch
      final batchJson = await createTelemetryBatch(eventsJson);
      final batch = jsonDecode(batchJson);

      // Send to PostHog (or your analytics backend)
      await _sendBatchToBackend(batch);

      // Mark as sent
      await markTelemetryBatchSent(batch['batch_id']);

      print('‚úÖ Synced ${events.length} events successfully');
    } catch (e) {
      print('‚ùå Sync failed: $e');
      // Events remain in queue for next sync attempt
    }
  }

  /// Cleanup old telemetry data
  Future<void> cleanupOld({int days = 30}) async {
    try {
      final deleted = await cleanupOldTelemetry(days);
      print('üóëÔ∏è  Cleaned up $deleted old events');
    } catch (e) {
      print('‚ùå Cleanup failed: $e');
    }
  }

  // Private methods

  Future<String> _getOrCreateUserId() async {
    // In production, load from secure storage
    // For now, generate a hash
    final timestamp = DateTime.now().millisecondsSinceEpoch.toString();
    final bytes = utf8.encode(timestamp);
    final digest = sha256.convert(bytes);
    return digest.toString().substring(0, 16);
  }

  Future<DeviceContext> _collectDeviceContext() async {
    // In production, use device_info_plus package
    return DeviceContext(
      appVersion: _version,
      platform: 'android', // or Platform.operatingSystem
      osVersion: '14', // from device_info_plus
      deviceModel: 'Pixel 8', // from device_info_plus
      locale: 'en-US', // from Localizations
    );
  }

  Future<void> _sendBatchToBackend(Map<String, dynamic> batch) async {
    // TODO: Implement actual HTTP POST to PostHog or your backend
    //
    // Example:
    // final response = await http.post(
    //   Uri.parse('https://posthog.example.com/batch'),
    //   headers: {'Content-Type': 'application/json'},
    //   body: jsonEncode(batch),
    // );
    //
    // if (response.statusCode != 200) {
    //   throw Exception('Failed to send batch: ${response.statusCode}');
    // }

    // For now, just simulate success
    await Future.delayed(const Duration(milliseconds: 100));
  }
}

// Data classes

class TelemetryConfig {
  final bool enabled;
  final int batchSize;
  final int batchMaxAgeSeconds;
  final int batchMaxSizeBytes;
  final bool wifiOnly;

  const TelemetryConfig({
    required this.enabled,
    required this.batchSize,
    required this.batchMaxAgeSeconds,
    required this.batchMaxSizeBytes,
    required this.wifiOnly,
  });
}

class DeviceContext {
  final String appVersion;
  final String platform;
  final String osVersion;
  final String deviceModel;
  final String locale;

  const DeviceContext({
    required this.appVersion,
    required this.platform,
    required this.osVersion,
    required this.deviceModel,
    required this.locale,
  });

  Map<String, dynamic> toJson() => {
    'app_version': appVersion,
    'platform': platform,
    'os_version': osVersion,
    'device_model': deviceModel,
    'locale': locale,
  };
}

class TelemetryStats {
  final int pendingEvents;
  final int batchedEvents;
  final int totalBatches;
  final int sentBatches;

  const TelemetryStats({
    required this.pendingEvents,
    required this.batchedEvents,
    required this.totalBatches,
    required this.sentBatches,
  });

  factory TelemetryStats.fromJson(Map<String, dynamic> json) {
    return TelemetryStats(
      pendingEvents: json['pending_events'] as int,
      batchedEvents: json['batched_events'] as int,
      totalBatches: json['total_batches'] as int,
      sentBatches: json['sent_batches'] as int,
    );
  }

  bool get isHealthy => pendingEvents < 50;

  String get healthStatus {
    if (pendingEvents > 100) return '‚ö†Ô∏è  WARNING';
    if (pendingEvents > 50) return '‚ö° ATTENTION';
    return '‚úÖ HEALTHY';
  }
}

// FFI Bridge stubs (replace with actual generated bindings)
//
// These would be auto-generated by flutter_rust_bridge from the Rust API

Future<void> trackEvent(
  String eventType, {
  String? sessionId,
  String? userId,
  required String propertiesJson,
  required String contextJson,
}) async {
  // Call Rust FFI function
  throw UnimplementedError('Replace with actual FFI call');
}

Future<String> getPendingTelemetryEvents(int limit) async {
  throw UnimplementedError('Replace with actual FFI call');
}

Future<String> createTelemetryBatch(String eventsJson) async {
  throw UnimplementedError('Replace with actual FFI call');
}

Future<void> markTelemetryBatchSent(String batchId) async {
  throw UnimplementedError('Replace with actual FFI call');
}

Future<String> getTelemetryStats() async {
  throw UnimplementedError('Replace with actual FFI call');
}

Future<int> cleanupOldTelemetry(int days) async {
  throw UnimplementedError('Replace with actual FFI call');
}

// Example usage in main app

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {
  final TelemetryService _telemetry = TelemetryService();
  DateTime? _sessionStartTime;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initTelemetry();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _telemetry.dispose();
    super.dispose();
  }

  Future<void> _initTelemetry() async {
    await _telemetry.initialize();
    _sessionStartTime = DateTime.now();
    await _telemetry.trackSessionStart();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
      // App going to background
      _onAppPause();
    } else if (state == AppLifecycleState.resumed) {
      // App returning to foreground
      _onAppResume();
    }
  }

  Future<void> _onAppPause() async {
    // Track session end
    if (_sessionStartTime != null) {
      final duration = DateTime.now().difference(_sessionStartTime!);
      await _telemetry.trackSessionEnd(duration.inSeconds);
    }

    // Sync before backgrounding
    await _telemetry.syncIfNeeded();
  }

  Future<void> _onAppResume() async {
    // Start new session
    _sessionStartTime = DateTime.now();
    await _telemetry.trackSessionStart();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'English Liminal',
      navigatorObservers: [
        TelemetryNavigatorObserver(_telemetry),
      ],
      home: const HomeScreen(),
    );
  }
}

/// Navigator observer for automatic screen tracking
class TelemetryNavigatorObserver extends NavigatorObserver {
  final TelemetryService _telemetry;

  TelemetryNavigatorObserver(this._telemetry);

  @override
  void didPush(Route route, Route? previousRoute) {
    super.didPush(route, previousRoute);
    if (route.settings.name != null) {
      _telemetry.trackScreenView(route.settings.name!);
    }
  }

  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    if (previousRoute?.settings.name != null) {
      _telemetry.trackScreenView(previousRoute!.settings.name!);
    }
  }
}
